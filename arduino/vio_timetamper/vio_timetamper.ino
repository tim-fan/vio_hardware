// VIO timestamper
// sketch to implementent the arduino side of a hardware synchronised visual-inertial odometry platform.
// The role of this sketch is to:
//   - publish IMU samples, and
//   - publish camera frame timestamps
//
// the camera frame timestamps are determined by montioring a digitial input, attached to the camera's output, configured
// to output 'exposure active' (i.e., to indicate when the camera is taking an image).
//
// All timestamps (camera and imu) are based on the arduino clock (micros()), so are expected to be synchronised
// 
// Messages are sent back to the host using rosserial - a bridge node needs to be run on the host computer to publish these
// messages to the wider ROS network.


// Much of the IMU code is copied from the MPU6050 library raw example

#include <Arduino.h>
#include <ros.h>
#include <ros/time.h>
#include <sensor_msgs/TimeReference.h>
#include <ros/duration.h>
#include <sensor_msgs/Imu.h>
#include <math.h>
#include <TimerThree.h>

// I2Cdev and MPU6050 must be installed as libraries, or else the .cpp/.h files
// for both classes must be in the include path of your project
#include "I2Cdev.h"
#include "MPU6050.h"

// Arduino Wire library is required if I2Cdev I2CDEV_ARDUINO_WIRE implementation
// is used in I2Cdev.h
#if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE
    #include "Wire.h"
#endif


////////////// Globals //////////////////////////

ros::NodeHandle  nh;

//camera related globals:
sensor_msgs::TimeReference timeRefMsg;
ros::Publisher timeRefPub("exposure_timestamps", &timeRefMsg);

int exposureActivePin = 2;
unsigned long minExposureTime = 10; //micros - assume exposures shorter than this are input bouncing

// imu related globals:
bool triggerImu = false;
double imuPubRate = 200; //Hz

//variables to catch timestamps of exposure start and end
unsigned long exposureStartTime = 0;
unsigned long exposureEndTime = 0;
unsigned long exposureLength = 0;
unsigned long exposureTime = 0; 
unsigned long lastExposureTime = 0;

sensor_msgs::Imu imu_msg;
ros::Publisher imu_pub("imu", &imu_msg);

//////////////// Class & Function Definitions ///////////////////////

// Timstamping notes:
// There seem to be concerns about how well rosserial maintains
// time-sync with the host system
// (see https://github.com/ros-drivers/rosserial/issues/392)
// I'm concerned this will interfere with the relative accuracy
// of timestamps generated by this script.
// Hence I get the ros::Time just once at the start of the script,
// then use arduino micros() to track elapsed time from this point.

class RosClock
{
  // responsible for providing ros timestamps, based on the current
  // arduino clock.
  // Gets intial time from rosserial, then uses arduino micros() function
  // to track time from that point onward.
  public:
    RosClock(){
      
    }
    void init(ros::NodeHandle  nh){    
      //wait for a clock value from the host
      while (nh.now().toSec() < 100)
      {
        nh.spinOnce();
        delay(10);
      }
      _referenceRosTime = nh.now();
      _referenceMicrosTime = micros();
    }
    
    ros::Time microsToRosTime(unsigned long microsTime){
         //return ros time corresponding to given micros value.
         //determine result by looking at difference in micros 
         //since last ros time
         
         ros::Time rosTime = _referenceRosTime;
         unsigned long microsSinceReference = microsTime - _referenceMicrosTime;
         rosTime += microsToDuration(microsSinceReference);
         return rosTime;
    }

    void update(void){
      //if the ros reference time is never updated, then 
      //when the difference between the current and reference time
      //becomes larger than an unsigned long in microseconds (about 70 minutes),
      //in which case results from microsToRosTime will be erroneous due to overflow.
      //Hence, lets update the ros reference time every, say, 30 minutes
    
      unsigned long currentMicros = micros();
      if ((currentMicros - _referenceMicrosTime) > 30 * 60 * 1000 * 1000)
      {
        _referenceRosTime = microsToRosTime(currentMicros);
        _referenceMicrosTime = currentMicros;
      }
      return;
    
    }
  private:
    ros::Time _referenceRosTime;
    unsigned long _referenceMicrosTime;
    unsigned long _oneMillion = 1000000; 
    
    ros::Duration microsToDuration(unsigned long microsTime){
        //convert a number of microseconds to a ros duration, 
        //for performing time arithmetic
        return ros::Duration(microsTime / _oneMillion, (microsTime % _oneMillion) * 1000.0);
    }

};
RosClock rosClock;


class ImuSampler
{
  //responsible for taking imu samples.

  public:
    ImuSampler(){}

    void init(){
      // join I2C bus (I2Cdev library doesn't do this automatically)
      #if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE
          Wire.begin();
      #elif I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE
          Fastwire::setup(400, true);
      #endif
      accelgyro.initialize();

      /// IMU config related stuff::: ///
      
          //Gyro scale selection:
      // * FS_SEL | Full Scale Range   | LSB Sensitivity
      // * -------+--------------------+----------------
      // * 0      | +/- 250 degrees/s  | 131 LSB/deg/s
      // * 1      | +/- 500 degrees/s  | 65.5 LSB/deg/s
      // * 2      | +/- 1000 degrees/s | 32.8 LSB/deg/s
      // * 3      | +/- 2000 degrees/s | 16.4 LSB/deg/s
  
      int gyroFS_SEL = 2;
      accelgyro.setFullScaleGyroRange(gyroFS_SEL); 
      double gyroToDegreesPerSec = pow(2, gyroFS_SEL) / 131.0;
      double degreesToRad = M_PI/180.0;    
      gyroScale = gyroToDegreesPerSec * degreesToRad;
      
  
      //Acceleration scale
      // * AFS_SEL | Full Scale Range | LSB Sensitivity
      // * --------+------------------+----------------
      // * 0       | +/- 2g           | 8192 LSB/mg
      // * 1       | +/- 4g           | 4096 LSB/mg
      // * 2       | +/- 8g           | 2048 LSB/mg
      // * 3       | +/- 16g          | 1024 LSB/mg
  
      int accelFS_SEL = 2;
      accelgyro.setFullScaleAccelRange(accelFS_SEL); 
      double accelToG =  pow(2, accelFS_SEL) / (8192.0 * 2);
      double gToMetersPerSec = 9.80665;
      accelScale = accelToG * gToMetersPerSec;
  
  
      //Setup low pass filter
      // *          |   ACCELEROMETER    |           GYROSCOPE
      // * DLPF_CFG | Bandwidth | Delay  | Bandwidth | Delay  | Sample Rate
      // * ---------+-----------+--------+-----------+--------+-------------
      // * 0        | 260Hz     | 0ms    | 256Hz     | 0.98ms | 8kHz
      // * 1        | 184Hz     | 2.0ms  | 188Hz     | 1.9ms  | 1kHz
      // * 2        | 94Hz      | 3.0ms  | 98Hz      | 2.8ms  | 1kHz
      // * 3        | 44Hz      | 4.9ms  | 42Hz      | 4.8ms  | 1kHz
      // * 4        | 21Hz      | 8.5ms  | 20Hz      | 8.3ms  | 1kHz
      // * 5        | 10Hz      | 13.8ms | 10Hz      | 13.4ms | 1kHz
      // * 6        | 5Hz       | 19.0ms | 5Hz       | 18.6ms | 1kHz
      // * 7        |   -- Reserved --   |   -- Reserved --   | Reserved
      int filterMode = 1;
      accelgyro.setDLPFMode(filterMode); 
  
  
      //To calibrate sensor offsets, run calibration sketch from here:
      //https://42bots.com/tutorials/arduino-script-for-mpu-6050-auto-calibration/
      //then enter offsets into fields below, uncomment, and run sketch.
  //    accelgyro.setXAccelOffset(-435);
  //    accelgyro.setYAccelOffset(831);
  //    accelgyro.setZAccelOffset(1120);
  //    accelgyro.setXGyroOffset(63);
  //    accelgyro.setYGyroOffset(61);
  //    accelgyro.setZGyroOffset(-9);
    }
    
    void read(sensor_msgs::Imu& imu_msg){
      
        // read raw accel/gyro measurements from device
        // assumes 'imu_msg' is global variable
        // note - this method does not update the msg timestamp - 
        // this should be done externally
        
        accelgyro.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
        imu_msg.linear_acceleration.x = ax * accelScale;
        imu_msg.linear_acceleration.y = ay * accelScale;
        imu_msg.linear_acceleration.z = az * accelScale;
        imu_msg.angular_velocity.x = gx * gyroScale;
        imu_msg.angular_velocity.y = gy * gyroScale;
        imu_msg.angular_velocity.z = gz * gyroScale;
   
    }
  private:
    MPU6050 accelgyro;
    int16_t ax, ay, az;
    int16_t gx, gy, gz;
    double gyroScale;
    double accelScale;
};
ImuSampler imu;


void exposureChangeISR(void)
{
    unsigned long exposureChangeTime = micros();
    bool exposureStart = !digitalRead(exposureActivePin);
    if (exposureStart) 
    {
      exposureStartTime = exposureChangeTime;
      exposureEndTime = 0;  
    }
    else //exposureEnd
    {
      exposureEndTime = exposureChangeTime;
      if (exposureStartTime != 0)
      {
          exposureLength = exposureEndTime - exposureStartTime;

          if (exposureLength > minExposureTime)
          {
            exposureTime = exposureStartTime + exposureLength / 2;
          }
           
      }
      exposureStartTime = 0;
      exposureEndTime = 0;
    }

}

void imuTriggerISR(){
  triggerImu = true;  
}

///////////// SETUP & LOOP ////////////////

void setup()
{
  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(exposureActivePin, INPUT);

  nh.initNode();
  
  nh.advertise(timeRefPub);
  nh.advertise(imu_pub);
  
  rosClock.init(nh);
  imu.init();

  Timer3.initialize(1000000.0/imuPubRate);
  Timer3.attachInterrupt(imuTriggerISR);

  attachInterrupt(exposureActivePin, exposureChangeISR, CHANGE);
}


void loop()
{ 
  rosClock.update();
  digitalWrite(LED_BUILTIN, !digitalRead(exposureActivePin));

  if (triggerImu)
  {
    imu_msg.header.stamp = rosClock.microsToRosTime(exposureTime);
    imu.read(imu_msg);
    
    imu_pub.publish(&imu_msg);
    triggerImu = false;  
  }

  if (exposureTime != lastExposureTime  )
  {
    lastExposureTime = exposureTime;
    ros::Time rosExposureTime = rosClock.microsToRosTime(exposureTime);
    timeRefMsg.header.stamp = rosExposureTime;
    timeRefMsg.time_ref = rosExposureTime;
    timeRefPub.publish( &timeRefMsg );
  }
  nh.spinOnce();
}


